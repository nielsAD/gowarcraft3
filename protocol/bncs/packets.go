// Author:  Niels A.D.
// Project: gowarcraft3 (https://github.com/nielsAD/gowarcraft3)
// License: Mozilla Public License, v2.0

package bncs

import (
	"math/bits"
	"net"
	"strconv"

	"github.com/nielsAD/gowarcraft3/protocol"
	"github.com/nielsAD/gowarcraft3/protocol/w3gs"
)

func readPacketHeader(buf *protocol.Buffer) (byte, int) {
	var bsize = buf.Size()
	if bsize < 4 {
		return 0, -1
	}
	buf.Skip(1)
	var pid = buf.ReadUInt8()
	var psize = int(buf.ReadUInt16())
	if psize > bsize {
		return pid, -1
	}
	return pid, psize
}

func readPacketSize(buf *protocol.Buffer) int {
	var _, psize = readPacketHeader(buf)
	return psize
}

// UnknownPacket is used to store unknown packets.
type UnknownPacket struct {
	ID   byte
	Blob []byte
}

// Serialize encodes the struct into its binary form.
func (pkt *UnknownPacket) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(pkt.ID)
	buf.WriteUInt16(uint16(4 + len(pkt.Blob)))
	buf.WriteBlob(pkt.Blob)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *UnknownPacket) Deserialize(buf *protocol.Buffer) error {
	var pid, size = readPacketHeader(buf)
	if size < 4 {
		return ErrInvalidPacketSize
	}

	pkt.ID = pid
	pkt.Blob = buf.ReadBlob(size - 4)

	return nil
}

// KeepAlive implements the [0x00] SID_Null packet (S -> C, C -> S).
//
// Keeps the connection alive. This message should be sent to the server every 8 minutes (approximately).
//
// The server will send this to you automatically, you do not have to reply to it. You should send this on your own never-ending timer for at least as often as Battle.net does (give or take a few seconds).
//
// This packet is used to detect if your TCP connection has gone dead, to the point where you will never receive data from the server ever again until you reconnect your connection. A situation such as this can be created by unplugging your internet connection for a few minutes, or if your internet is dropped for whatever reason.
//
// Format:
//
//    [blank]
//
type KeepAlive struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *KeepAlive) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidNull)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *KeepAlive) Deserialize(buf *protocol.Buffer) error {
	if readPacketSize(buf) != 4 {
		return ErrInvalidPacketSize
	}
	return nil
}

// Ping implements the [0x25] SID_Ping packet (S -> C, C -> S).
//
// Used to calculate Client's ping. The received UINT32 should be sent directly back to Battle.net.
//
// The ping displayed when in chat can be artificially inflated by delaying before sending this packet, or deflated by responding before requested.
// Ping can be set to -1 (Strictly speaking, 0xFFFFFFFF, since ping is unsigned) by not responding to this packet at all.
//
// The received UINT32 is not what determines your ping, but it is actually a cookie for the Battle.net server. You should never change the UINT32.
//
// Format:
//
//    (UINT32) Ping Value
//
type Ping struct {
	Payload uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *Ping) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPing)
	buf.WriteUInt16(8)
	buf.WriteUInt32(pkt.Payload)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *Ping) Deserialize(buf *protocol.Buffer) error {
	if readPacketSize(buf) != 8 {
		return ErrInvalidPacketSize
	}
	pkt.Payload = buf.ReadUInt32()
	return nil
}

// EnterChatReq implements the [0x0A] SID_EnterChat packet (C -> S).
//
// Joins Chat.
//
// Username: Null on WAR3/W3XP.
//
// StatString: Null on CDKey Products, except for D2DV and D2XP when on realm characters..
//
// Format:
//
//    (STRING) Username
//    (STRING) StatString
//
type EnterChatReq struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *EnterChatReq) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidEnterChat)
	buf.WriteUInt16(6)
	buf.WriteUInt16(0)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *EnterChatReq) Deserialize(buf *protocol.Buffer) error {
	if readPacketSize(buf) != 6 {
		return ErrInvalidPacketSize
	}
	if buf.ReadUInt16() != 0 {
		return ErrUnexpectedConst
	}
	return nil
}

// EnterChatResp implements the [0x0A] SID_EnterChat packet (S -> C).
//
// Contains Client product, realm, statstring, and is sent as the response when the client sends SID_EnterChat. Unique name is the users unique name in chat (Which may be Arta, Arta#2, Arta#3, etc).  Account name is the users account name (Which in all 3 previous examples would be Arta).
//
// Once you receive this packet, you are not in a channel, but can join/host games and join channels. Because you are not in a channel, you cannot send text messages yet (but you will not be disconnected if you do). See SID_JoinChannel.
//
// Format:
//
//    (STRING) Unique name
//    (STRING) StatString
//    (STRING) Account name
//
type EnterChatResp struct {
	UniqueName  string
	StatString  string
	AccountName string
}

// Serialize encodes the struct into its binary form.
func (pkt *EnterChatResp) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidEnterChat)
	buf.WriteUInt16(uint16(7 + len(pkt.UniqueName) + len(pkt.StatString) + len(pkt.AccountName)))
	buf.WriteCString(pkt.UniqueName)
	buf.WriteCString(pkt.StatString)
	buf.WriteCString(pkt.AccountName)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *EnterChatResp) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 7 {
		return ErrInvalidPacketSize
	}
	var err error
	if pkt.UniqueName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size < 7+len(pkt.UniqueName) {
		return ErrInvalidPacketSize
	}
	if pkt.StatString, err = buf.ReadCString(); err != nil {
		return err
	}
	if size < 7+len(pkt.UniqueName)+len(pkt.StatString) {
		return ErrInvalidPacketSize
	}
	if pkt.AccountName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 7+len(pkt.UniqueName)+len(pkt.StatString)+len(pkt.AccountName) {
		return ErrInvalidPacketSize
	}
	return nil
}

// JoinChannel implements the [0x0C] SID_JoinChannel packet (C -> S).
//
// Joins a channel after entering chat.
//
// The Channel name must be no greater than 31 characters, otherwise it becomes trimmed by Battle.net.
//
// The flags field may contain the following values:
//   0x00: NoCreate join
//   0x01: First join
//   0x02: Forced join
//   0x05: D2 first join
//
// NoCreate Join:
//   This will only join the channel specified if it is not empty, and is used by clients when selecting a channel from the channels menu. If the channel is empty, Battle.net sends a SID_ChatEvent of type EID_CHANNELDOESNOTEXIST, upon which official clients prompt for confirmation that the user wishes to create the channel, in which case, it resends this packet with Flags set to Forced Join (0x02).
// First Join:
//   Places user in a channel starting with their product and country, followed by a number, ie 'Brood War GBR-1'. Also automatically sends MOTD after entering the channel. When using this type, the Channel variable has no effect, but must be present anyway to avoid an IP ban. This is sent when first logging onto Battle.net
// Forced Join:
//   This is sent when leaving a game, and joins the specified channel without an supplying an MOTD.
// D2 First Join:
//   The same as First join, but is used for D2DV/D2XP clients.
//
// Format:
//
//    (UINT32) Flags
//    (STRING) Channel
//
type JoinChannel struct {
	Flag    JoinChannelFlag
	Channel string
}

// Serialize encodes the struct into its binary form.
func (pkt *JoinChannel) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidJoinChannel)
	buf.WriteUInt16(uint16(9 + len(pkt.Channel)))
	buf.WriteUInt32(uint32(pkt.Flag))
	buf.WriteCString(pkt.Channel)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *JoinChannel) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 9 {
		return ErrInvalidPacketSize
	}

	pkt.Flag = JoinChannelFlag(buf.ReadUInt32())

	var err error
	if pkt.Channel, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 9+len(pkt.Channel) {
		return ErrInvalidPacketSize
	}
	return nil
}

// ChatCommand implements the [0x0E] SID_ChatCommand packet (C -> S).
//
// Send text or a command to Battle.net using this packet.
//
// For STAR/SEXP/SSHR/JSTR, Text is UTF-8 encoded (WIDESTRING).
//
// It is generally accepted as unwise to send any character below a space (0x20): this includes line feeds, carriage returns & control characters. The maximum number of characters is 224 per message including the null-terminator (so really only 223 characters), any longer and it becomes trimmed by Battle.net.
//
// If you send a line feed and/or a carriage return, Battle.net disconnects you and IP bans you for 5 minutes.
//
// Format:
//
//    (STRING) Text
//
type ChatCommand struct {
	Text string
}

// Serialize encodes the struct into its binary form.
func (pkt *ChatCommand) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidChatCommand)
	buf.WriteUInt16(uint16(5 + len(pkt.Text)))
	buf.WriteCString(pkt.Text)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *ChatCommand) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 5 {
		return ErrInvalidPacketSize
	}
	var err error
	if pkt.Text, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 5+len(pkt.Text) {
		return ErrInvalidPacketSize
	}
	return nil
}

// ChatEvent implements the [0x0F] SID_ChatEvent packet (S -> C).
//
// Contains all chat events.
//
// Text: For STAR/SEXP/SSHR/JSTR, this field is UTF-8 encoded. For all other clients, it is ISO 8859-1 encoded. It must also be no longer than 255 characters; official clients should only be able to send 224 characters (including the null-terminator).
//
// Event IDs:
//   0x01 EID_SHOWUSER: User in channel
//   0x02 EID_JOIN: User joined channel
//   0x03 EID_LEAVE: User left channel
//   0x04 EID_WHISPER: Recieved whisper
//   0x05 EID_TALK: Chat text
//   0x06 EID_BROADCAST: Server broadcast
//   0x07 EID_CHANNEL: Channel information
//   0x09 EID_USERFLAGS: Flags update
//   0x0A EID_WHISPERSENT: Sent whisper
//   0x0D EID_CHANNELFULL: Channel full
//   0x0E EID_CHANNELDOESNOTEXIST: Channel doesn't exist
//   0x0F EID_CHANNELRESTRICTED: Channel is restricted
//   0x12 EID_INFO: Information
//   0x13 EID_ERROR: Error message
//   0x15 EID_IGNORE: Notifies that a user has been ignored (DEFUNCT)
//   0x16 EID_ACCEPT: Notifies that a user has been unignored (DEFUNCT)
//   0x17 EID_EMOTE: Emote
//
//
// EID_SHOWUSER:
//   This is sent for each user who is already in a channel when you join it, as opposed to EID_JOIN, which is sent when a user joins a channel you have already joined. It is also sent when logged on using D2XP/D2DV and a user requires an update to their statstring - for example, by logging a different character onto a realm.
//
// EID_JOIN:
//   This is sent when a user enters the channel you are currently in.
//
// EID_LEAVE:
//   This is sent when a user exits the channel you are currently in.
//
// EID_WHISPER:
//   This is sent when a user whispers you.
//
// EID_TALK:
//   This is sent when a user (excluding self) in chat speaks.
//
// EID_BROADCAST:
//   This is sent when a server announcement is being made globally.
//   The username supplied for this event is now always `Battle.net`. Historically, the username was the name of the Battle.net Administrator who sent the broadcast.
//
// EID_CHANNEL:
//   The flags field for this event is used and indicates what special conditions exist for the channel in question.
//
// EID_USERFLAGS:
//   This is sent to inform the client of an update to one or more user's flags.
//   Battle.net usually sends this event for every user in the channel, even if only one user's flags have changed. This behavior can be exploited to detect invisible users, by performing an action (such as an unsquelch) to provoke a flags update. Users included in the flags update whose presence has not been indicated by `EID_JOIN` or `EID_SHOWUSER` can then be added to the userlist as invisible. Care should be taken, however, to account for the possibility that an asynchronous send error has occurred. Should an `EID_JOIN` or `EID_SHOWUSER` event occur for an invisible user, they should be marked as a normal user, not readded to the userlist.
//
// EID_WHISPERSENT:
//   The Flags and Ping fields in this packet is equal to the originating user - the one who sent the whisper. In other words, `EID_WHISPERSENT` contains your flags &amp; ping, not those of the person you whispered.
//
// EID_CHANNELDOESNOTEXIST:
//   See info on `NoCreate Join` in SID_JoinChannel.
//
// EID_CHANNELRESTRICTED:
//   This is sent when attempting to join a channel which your client is not allowed to join.
//
// EID_INFO:
//   This is information supplied by Battle.net. This text is usually displayed by clients in yellow.
//
// EID_ERROR:
//   This is error information supplied by Battle.net. This text is usually displayed by clients in red.
//
// EID_EMOTE:
//   This is sent when any user (including self) uses the emote feature in chat.
//
// Format:
//
//    (UINT32) Event ID
//    (UINT32) User's Flags
//    (UINT32) Ping
//    (UINT32) IP Address             (defunct 0x00000000)
//    (UINT32) Account number         (defunct 0x00000000)
//    (UINT32) Registration Authority (defunct 0x00000000)
//    (STRING) Username
//    (STRING) Text
//
type ChatEvent struct {
	Type      ChatEventType
	UserFlags uint32
	Ping      uint32
	UserName  string
	Text      string
}

// Serialize encodes the struct into its binary form.
func (pkt *ChatEvent) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidChatEvent)
	buf.WriteUInt16(uint16(30 + len(pkt.UserName) + len(pkt.Text)))
	buf.WriteUInt32(uint32(pkt.Type))
	buf.WriteUInt32(pkt.UserFlags)
	buf.WriteUInt32(pkt.Ping)
	buf.WriteUInt32(0)
	buf.WriteUInt32(0xbaadf00d)
	buf.WriteUInt32(0xbaadf00d)
	buf.WriteCString(pkt.UserName)
	buf.WriteCString(pkt.Text)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *ChatEvent) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 30 {
		return ErrInvalidPacketSize
	}

	pkt.Type = ChatEventType(buf.ReadUInt32())
	pkt.UserFlags = buf.ReadUInt32()
	pkt.Ping = buf.ReadUInt32()

	if buf.ReadUInt32() != 0 || buf.ReadUInt32() != 0xbaadf00d || buf.ReadUInt32() != 0xbaadf00d {
		return ErrUnexpectedConst
	}

	var err error
	if pkt.UserName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size < 30+len(pkt.UserName) {
		return ErrInvalidPacketSize
	}
	if pkt.Text, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 30+len(pkt.UserName)+len(pkt.Text) {
		return ErrInvalidPacketSize
	}
	return nil
}

// FloodDetected implements the [0x13] SID_FloodDetected packet (S -> C).
//
// Sent prior to a disconnect along with SID_MessageBox to indicate that the client has flooded off.
//
// Format:
//
//    [blank]
//
type FloodDetected struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *FloodDetected) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidFloodDetected)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *FloodDetected) Deserialize(buf *protocol.Buffer) error {
	if readPacketSize(buf) != 4 {
		return ErrInvalidPacketSize
	}
	return nil
}

// MessageBox implements the [0x19] SID_MessageBox packet (S -> C).
//
// Displays a message to the user. This message's fields are used as parameters for the Win32 MessageBox API (http://msdn.microsoft.com/en-us/library/windows/desktop/ms645505(v=vs.85).aspx), and can be passed directly to it.
//
// Format:
//
//    (UINT32) Style
//    (STRING) Text
//    (STRING) Caption
//
type MessageBox struct {
	Style   uint32
	Text    string
	Caption string
}

// Serialize encodes the struct into its binary form.
func (pkt *MessageBox) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMessageBox)
	buf.WriteUInt16(uint16(10 + len(pkt.Text) + len(pkt.Caption)))
	buf.WriteUInt32(pkt.Style)
	buf.WriteCString(pkt.Text)
	buf.WriteCString(pkt.Caption)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *MessageBox) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 10 {
		return ErrInvalidPacketSize
	}

	pkt.Style = buf.ReadUInt32()

	var err error
	if pkt.Text, err = buf.ReadCString(); err != nil {
		return err
	}
	if size < 10+len(pkt.Text) {
		return ErrInvalidPacketSize
	}
	if pkt.Caption, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 10+len(pkt.Text)+len(pkt.Caption) {
		return ErrInvalidPacketSize
	}
	return nil
}

// GameSettings stores the settings of a created game.
//
//  This field still conforms to being a null-terminated string by encoding the data such that there are no null characters within.
//  The first 9 `UINT8`s are characters representing hexadecimal integers (`0` through `9` and `a` through `f`).
//  After this, the rest of the data is encoded in a manner in order to contain nulls when decoded, but be stored within this null-terminated string.
//
//  Format:
//   (CHAR)    Number of free slots (ex: `7` for 7 free slots)
//   (CHAR)[8] Host counter (reversed hexadecimal integer, ex: `20000000` for second time this host has hosted during his session)
//   Encoded data:
//      (UINT32) Map flags (combine the below settings):
//         Game speed (mask 0x00000003, unique):
//             `0x00000000`: Slow
//             `0x00000001`: Normal
//             `0x00000002`: Fast
//         Visibility setting (mask 0x00000F00, unique):
//             `0x00000100`: Hide Terrain
//             `0x00000200`: Map Explored
//             `0x00000400`: Always Visible
//             `0x00000800`: Default
//         Observers setting (mask 0x40003000, unique):
//             `0x00000000`: No Observers
//             `0x00002000`: Observers on Defeat
//             `0x00003000`: Full Observers
//             `0x40000000`: Referees
//         Other advanced host settings (mask 0x07064000, combinable):
//             `0x00004000`: Teams Together (team members are placed at neighbored starting locations)
//             `0x00060000`: Lock Teams
//             `0x01000000`: Full Shared Unit Control
//             `0x02000000`: Random Hero
//             `0x04000000`: Random Races
//      (UINT8) Map null 1
//      (UINT8) Map width (playable area)
//      (UINT8) Map null 2
//      (UINT8) Map height (playable area)
//      (UINT8) Map null 3
//     (UINT32) Map CRC
//     (STRING) Map path
//     (STRING) Game host name
//      (UINT8) Map unknown (possibly a STRING with just the null terminator)
//      (UINT8)[20] Unknown (probably a SHA1 hash)
//
// Format:
//
//    (UINT32)     Flags
//    (UINT16)     Map width
//    (UINT16)     Map height
//    (UINT32)     Map xoro
//    (STRING)     Map path
//    (STRING)     Host name
//     (UINT8)[20] Map Sha1 hash
//
// Encoded as a null terminated string where every even byte-value was
// incremented by 1. So all encoded bytes are odd. A control-byte stores
// the transformations for the next 7 bytes.
//
type GameSettings struct {
	SlotsFree    uint8
	HostCounter  uint32
	GameSettings w3gs.GameSettings
}

// Size of Serialize()
func (gs *GameSettings) Size() int {
	return 9 + gs.GameSettings.Size()
}

// Serialize GameSettings into StatString
func (gs *GameSettings) Serialize(buf *protocol.Buffer) {
	if gs.SlotsFree >= 10 {
		buf.WriteUInt8('1' + '0' + gs.SlotsFree - 10)
	} else {
		buf.WriteUInt8('0' + gs.SlotsFree)
	}

	// Hexadecimal in reverse ordering with 0 padding until 8 bytes
	var b = []byte{'0', '0', '0', '0', '0', '0', '0', '0'}
	var c = bits.ReverseBytes32(gs.HostCounter)
	c = c&0x0F0F0F0F<<4 | c&0xF0F0F0F0>>4
	strconv.AppendInt(b[:0], int64(c), 16)
	buf.WriteBlob(b)

	gs.GameSettings.Serialize(buf)
}

// Deserialize GameSettings from StatString
func (gs *GameSettings) Deserialize(buf *protocol.Buffer) error {
	gs.SlotsFree = buf.ReadUInt8()
	if gs.SlotsFree >= '1'+'0' {
		gs.SlotsFree -= '1' + '0' - 10
	} else if gs.SlotsFree >= '0' {
		gs.SlotsFree -= '0'
	}

	// Hexadecimal in reverse ordering with 0 padding until 8 bytes
	var b = string(buf.ReadBlob(8))
	if c, err := strconv.ParseUint(b, 16, 32); err == nil {
		c = c&0x0F0F0F0F<<4 | c&0xF0F0F0F0>>4
		gs.HostCounter = uint32(bits.ReverseBytes32(uint32(c)))
	} else {
		return err
	}

	if err := gs.GameSettings.Deserialize(buf); err != nil {
		return err
	}

	return nil
}

// GetAdvListResp implements the [0x09] SID_GetAdvListEx packet (S -> C).
//
// Returns a list of available games and their information. Values vary depending on product.
//
// The Game settings field is a combination of values.
//    WarCraft III (WAR3/W3XP): combine the below settings
//       Game type (mask `0x000000FF`, unique)
//          `0x00000001`: Custom
//          `0x00000009`: Ladder
//       Public/private (mask `0x00000800`, unique)
//          `0x00000000`: Public game
//          `0x00000800`: Private game
//       Map author ID (mask `0x00006000`, combinable)
//          `0x00002000`: Blizzard
//          `0x00004000`: Custom
//       Battle/scenario (mask `0x00018000`, unique)
//          `0x00000000`: Battle
//          `0x00010000`: Scenario
//       Map size (mask `0x000E0000`, combinable)
//          `0x00020000`: Small
//          `0x00040000`: Medium
//          `0x00080000`: Huge
//       Observers (mask `0x00070000`, unique)
//          `0x00100000`: Allowed observers ("Full Observers" and "Referees" options)
//          `0x00200000`: Observers on defeat
//          `0x00400000`: No observers
//
// The Address Family, Port, Host's IP, and sin_zero fields form a sockaddr_in(https://msdn.microsoft.com/en-us/library/zx63b042.aspx) structure.
//
// The Game status field varies by product.
//    WarCraft III (WAR3/W3XP):
//       `0x00000010`: Public
//       `0x00000011`: Private
//      When there are no entries returned, the Status field uses this list of results, as well.
//       `0x00000000`: OK
//       `0x00000001`: Game doesn't exist
//       `0x00000002`: Incorrect password
//       `0x00000003`: Game full
//       `0x00000004`: Game already started
//       `0x00000005`: Spawned CD-Key not allowed
//       `0x00000006`: Too many server requests
//
// The Game name field is UTF-8 encoded.
//
// The Game password field is always empty on WarCraft III.
//
// The Game statstring field contains more information that is very specific to each product.
//
// Format:
//
//    (UINT32) Number of games
//
//    If count is 0:
//       (UINT32) Status
//
//    Otherwise, games are listed thus:
//       For each list item:
//          (UINT32) Game settings
//          (UINT32) Language ID
//          (UINT16) Address Family (Always AF_INET)
//          (UINT16) Port
//          (UINT32) Host's IP
//          (UINT32) sin_zero (0)
//          (UINT32) sin_zero (0)
//          (UINT32) Game status
//          (UINT32) Elapsed time (in seconds)
//          (STRING) Game name
//          (STRING) Game password
//          (STRING) Game statstring
//
type GetAdvListResp struct {
	Result AdvListResult    //If count is 0
	Games  []GetAdvListGame //Otherwise
}

// GetAdvListGame stores a game in GetAdvList.
//
// Format:
//    (UINT32) Game settings
//    (UINT32) Language ID
//    (UINT16) Address Family (Always AF_INET)
//    (UINT16) Port
//    (UINT32) Host's IP
//    (UINT32) sin_zero (0)
//    (UINT32) sin_zero (0)
//    (UINT32) Game status
//    (UINT32) Elapsed time (in seconds)
//    (STRING) Game name
//    (STRING) Game password
//    (STRING) Game statstring
//
type GetAdvListGame struct {
	GameFlags      w3gs.GameFlags
	LanguageID     uint32
	Addr           protocol.SockAddr
	GameStateFlags GameStateFlags
	UptimeSec      uint32
	GameName       string
	GameSettings   GameSettings
}

// Serialize encodes the struct into its binary form.
func (pkt *GetAdvListResp) Serialize(buf *protocol.Buffer) error {
	var start = buf.Size()
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidGetAdvListEx)

	// Placeholder for size
	buf.WriteUInt16(0)

	if len(pkt.Games) == 0 {
		buf.WriteUInt32(0)
		buf.WriteUInt32(uint32(pkt.Result))
	} else {
		buf.WriteUInt32(uint32(len(pkt.Games)))
		for i := 0; i < len(pkt.Games); i++ {
			buf.WriteUInt32(uint32(pkt.Games[i].GameFlags))
			buf.WriteUInt32(pkt.Games[i].LanguageID)
			buf.WriteSockAddr(&pkt.Games[i].Addr)
			buf.WriteUInt32(uint32(pkt.Games[i].GameStateFlags))
			buf.WriteUInt32(pkt.Games[i].UptimeSec)
			buf.WriteCString(pkt.Games[i].GameName)
			buf.WriteUInt8(0)
			pkt.Games[i].GameSettings.Serialize(buf)
		}
	}

	// Set size
	buf.WriteUInt16At(start+2, uint16(buf.Size()-start))

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *GetAdvListResp) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 12 {
		return ErrInvalidPacketSize
	}

	var numGames = int(buf.ReadUInt32())
	if cap(pkt.Games) < numGames {
		pkt.Games = make([]GetAdvListGame, 0, numGames)
	}
	pkt.Games = pkt.Games[:numGames]

	if numGames == 0 {
		if size != 12 {
			return ErrInvalidPacketSize
		}
		pkt.Result = AdvListResult(buf.ReadUInt32())
		return nil
	}

	pkt.Result = AdvListSuccess

	size -= 8
	for i := 0; i < len(pkt.Games); i++ {
		if size < 35 {
			return ErrInvalidPacketSize
		}

		pkt.Games[i].GameFlags = w3gs.GameFlags(buf.ReadUInt32())
		pkt.Games[i].LanguageID = buf.ReadUInt32()

		var err error
		if pkt.Games[i].Addr, err = buf.ReadSockAddr(); err != nil {
			return err
		}

		pkt.Games[i].GameStateFlags = GameStateFlags(buf.ReadUInt32())
		pkt.Games[i].UptimeSec = buf.ReadUInt32()

		if pkt.Games[i].GameName, err = buf.ReadCString(); err != nil {
			return err
		}

		size -= 33 + len(pkt.Games[i].GameName)
		if size < 2 {
			return ErrInvalidPacketSize
		}

		if buf.ReadUInt8() != 0 {
			return ErrUnexpectedConst
		}

		if err = pkt.Games[i].GameSettings.Deserialize(buf); err != nil {
			return err
		}

		size -= 1 + pkt.Games[i].GameSettings.Size()
	}

	if size != 0 {
		return ErrInvalidPacketSize
	}

	return nil
}

// GetAdvListReq implements the [0x09] SID_GetAdvListEx packet (C -> S).
//
// Retrieves a list of games.
//
// Viewing Filter:
//   0xFFFF is used to use the combination of values in this packet.
//   0xFF80 is used to show all games.
//   For STAR/SEXP/SSHR/JSTR, viewing filter is set to 0x30.
//   For DRTL/DSHR, viewing filter is set to 0xFFFF by the game, but setting it to 0x00 will disable any viewing limitations, letting you view all games.
// Reserved (0):
//   This value is hardcoded to 0x00 by all games.
// Number of Games:
//   This is the number of games to list. For a full listing, it's safe to use 0xFF. By default, DRTL/DSHR sets this to 0x19.
//
// Format:
//
//    (UINT16) Game Type
//    (UINT16) Sub Game Type
//    (UINT32) Viewing Filter
//    (UINT32) Reserved (0)
//    (UINT32) Number of Games
//    (STRING) Game Name
//    (STRING) Game Password
//    (STRING) Game Statstring
//
type GetAdvListReq struct {
	Filter        w3gs.GameFlags
	FilterMask    w3gs.GameFlags
	NumberOfGames uint32
	GameName      string
}

// Serialize encodes the struct into its binary form.
func (pkt *GetAdvListReq) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidGetAdvListEx)
	buf.WriteUInt16(uint16(23 + len(pkt.GameName)))
	buf.WriteUInt32(uint32(pkt.Filter))
	buf.WriteUInt32(uint32(pkt.FilterMask))
	buf.WriteUInt32(0)
	buf.WriteUInt32(pkt.NumberOfGames)
	buf.WriteCString(pkt.GameName)
	buf.WriteUInt8(0)
	buf.WriteUInt8(0)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *GetAdvListReq) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 23 {
		return ErrInvalidPacketSize
	}

	pkt.Filter = w3gs.GameFlags(buf.ReadUInt32())
	pkt.FilterMask = w3gs.GameFlags(buf.ReadUInt32())

	if buf.ReadUInt32() != 0 {
		return ErrUnexpectedConst
	}

	pkt.NumberOfGames = buf.ReadUInt32()

	var err error
	if pkt.GameName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 23+len(pkt.GameName) {
		return ErrInvalidPacketSize
	}

	if buf.ReadUInt8() != 0 || buf.ReadUInt8() != 0 {
		return ErrUnexpectedConst
	}

	return nil
}

// StartAdvex3Resp implements the [0x1C] SID_StartAdvex3 packet (S -> C).
//
// Possible values for Status:
//   0x00: Ok
//   0x01: Failed
//
// Format:
//
//    (UINT32) Status
//
type StartAdvex3Resp struct {
	Failed bool
}

// Serialize encodes the struct into its binary form.
func (pkt *StartAdvex3Resp) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidStartAdvex3)
	buf.WriteUInt16(8)
	buf.WriteBool32(pkt.Failed)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *StartAdvex3Resp) Deserialize(buf *protocol.Buffer) error {
	if readPacketSize(buf) != 8 {
		return ErrInvalidPacketSize
	}
	pkt.Failed = buf.ReadBool32()
	return nil
}

// StartAdvex3Req implements the [0x1C] SID_StartAdvex3 packet (C -> S).
//
// Used by clients to inform the server that a game has been created, or that the state of a created game has changed.
//
// Bitwise flags for `State`:
//
//   0x01: Game is private
//   0x02: Game is full
//   0x04: Game contains players (other than creator)
//   0x08: Game is in progress
//   0x80: Game is a replay
//
//
// Possible values for `Game Type` (and `Sub Game Type`):
//
//   0x02: Melee
//   0x03: Free for All
//   0x04: 1 vs 1
//   0x05: Capture The Flag
//   0x06: Greed (Resources, 0x01: 2500, 0x02: 500, 0x03: 7500, 0x04: 10000)
//   0x07: Slaughter (Minutes, 0x01: 15, 0x02: 30, 0x03: 45, 0x04: 60)
//   0x08: Sudden Death
//   0x09: Ladder (Disconnects, 0x00: Not a loss, 0x01: Counts as a loss)
//   0x0A: Use Map Settings
//   0x0B: Team Melee (Number Of Teams, 0x01: 2 Teams, 0x02: 3 Teams, etc.)
//   0x0C: Team Free For All (Number Of Teams, 0x01: 2 Teams, 0x02: 3 Teams, etc.)
//   0x0D: Team Capture The Flag (Number Of Teams, 0x01: 2 Teams, 0x02: 3 Teams, etc.)
//   0x0F: Top vs. Bottom (Number Of Teams, 1-7 specifies the ratio of players belonging to both teams)
//   0x10: Iron Man Ladder (W2BN only)
//   0x20: PGL
//
//
// `Provider Version Constant`: The current version of the game (1.16.1) uses `0xFF`, previous versions have used `0x1F`, but this may vary depending on game version.
//
// Possible values for `Ladder`:
//
//   0x00: Game is Normal (Non-Ladder)
//   0x01: Game is Ladder
//   0x03: Game is Iron Man Ladder (W2BN only)
//
// It could be that the `Ladder` is bitwise as well, and that `0x02` means Iron Man and `0x03` just means Iron Man + Ladder.
//
// `Sub Game Type` appears to be `0x01` for all game types except Top vs Bottom, where it seems to depend on the size of each team. More research will be needed to confirm.
//
// Format:
//
//    (UINT32) Game State
//    (UINT32) Game Uptime in seconds
//    (UINT16) Game Type
//    (UINT16) Sub Game Type
//    (UINT32) Provider Version Constant (0x03FF)
//    (UINT32) Ladder Type
//    (STRING) Game Name
//    (STRING) Game Password
//    (STRING) Game Statstring
//
type StartAdvex3Req struct {
	GameStateFlags GameStateFlags
	UptimeSec      uint32
	GameFlags      w3gs.GameFlags
	Ladder         bool
	GameName       string
	GameSettings   GameSettings
}

// Serialize encodes the struct into its binary form.
func (pkt *StartAdvex3Req) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidStartAdvex3)
	buf.WriteUInt16(uint16(26 + len(pkt.GameName) + pkt.GameSettings.Size()))

	buf.WriteUInt32(uint32(pkt.GameStateFlags))
	buf.WriteUInt32(pkt.UptimeSec)
	buf.WriteUInt32(uint32(pkt.GameFlags))
	buf.WriteUInt32(0x03FF)
	buf.WriteBool32(pkt.Ladder)
	buf.WriteCString(pkt.GameName)
	buf.WriteUInt8(0)
	pkt.GameSettings.Serialize(buf)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *StartAdvex3Req) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 27 {
		return ErrInvalidPacketSize
	}

	pkt.GameStateFlags = GameStateFlags(buf.ReadUInt32())
	pkt.UptimeSec = buf.ReadUInt32()
	pkt.GameFlags = w3gs.GameFlags(buf.ReadUInt32())

	if buf.ReadUInt32() != 0x03FF {
		return ErrUnexpectedConst
	}

	pkt.Ladder = buf.ReadBool32()

	var err error
	if pkt.GameName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size < 27+len(pkt.GameName) {
		return ErrInvalidPacketSize
	}

	if buf.ReadUInt8() != 0 {
		return ErrUnexpectedConst
	}

	if err = pkt.GameSettings.Deserialize(buf); err != nil {
		return err
	}
	if size != 26+len(pkt.GameName)+pkt.GameSettings.Size() {
		return ErrInvalidPacketSize
	}

	return nil
}

// StopAdv implements the [0x02] SID_StopAdv packet (C -> S).
//
// This message is sent to inform the server that a game should no longer be advertised to other users. It is sent when a game starts, or when a game is aborted (the host leaves).
//
// All Battle.snp clients (DRTL, DSHR, STAR/SEXP, JSTR, SSHR, and W2BN) always send this message when logging off, even if it not in a game.
//
// Format:
//
//    [blank]
//
type StopAdv struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *StopAdv) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidStopAdv)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *StopAdv) Deserialize(buf *protocol.Buffer) error {
	if readPacketSize(buf) != 4 {
		return ErrInvalidPacketSize
	}
	return nil
}

// NotifyJoin implements the [0x22] SID_NotifyJoin packet (C -> S).
//
// Notifies Battle.net that the client has joined a game. This is what causes you to receive "Your friend _ entered a _ game called _." from Battle.net if you are mutual friends with this client.
//
// SID_LeaveChat (0x10) does not need to be sent after this, since this does what LeaveChat does but with an added notification.
//
// ProductID: This can be any valid Product ID, even if you are not connected with that ID.
//
// Format:
//
//    (UINT32) Product ID
//    (UINT32) Product version
//    (STRING) Game Name
//    (STRING) Game Password
//
type NotifyJoin struct {
	GameVersion w3gs.GameVersion
	GameName    string
}

// Serialize encodes the struct into its binary form.
func (pkt *NotifyJoin) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidNotifyJoin)
	buf.WriteUInt16(uint16(14 + len(pkt.GameName)))
	pkt.GameVersion.Serialize(buf)
	buf.WriteCString(pkt.GameName)
	buf.WriteUInt8(0)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *NotifyJoin) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 14 {
		return ErrInvalidPacketSize
	}

	pkt.GameVersion.Deserialize(buf)

	var err error
	if pkt.GameName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 14+len(pkt.GameName) {
		return ErrInvalidPacketSize
	}

	if buf.ReadUInt8() != 0 {
		return ErrUnexpectedConst
	}

	return nil
}

// NetGamePort implements the [0x45] SID_NetGamePort packet (C -> S).
//
// Sets the port used by the client for hosting WAR3/W3XP games. This value is retreived from HKCU\Software\Blizzard Entertainment\Warcraft III\Gameplay\netgameport, and is sent after the user logs on.
//
// Format:
//
//    (UINT16) Port
//
type NetGamePort struct {
	Port uint16
}

// Serialize encodes the struct into its binary form.
func (pkt *NetGamePort) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidNetGamePort)
	buf.WriteUInt16(6)
	buf.WriteUInt16(pkt.Port)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *NetGamePort) Deserialize(buf *protocol.Buffer) error {
	if readPacketSize(buf) != 6 {
		return ErrInvalidPacketSize
	}
	pkt.Port = buf.ReadUInt16()
	return nil
}

// AuthInfoResp implements the [0x50] SID_AUTH_INFO packet (S -> C).
//
// Contains the Server Token, and the values used in CheckRevision.
//
// Possible Logon type values:
//
//   `0x00`: Broken SHA-1 (STAR/SEXP/D2DV/D2XP)
//   `0x01`: NLS version 1 (War3Beta)
//   `0x02`: NLS Version 2 (WAR3/W3XP)
//
// UDP value: No one really knows what this is, however, it is used in 2nd UINT32 of the UDP packet PKT_CONNTEST2. It is also the second part of MCP Chunk 1 in MCP_STARTUP.
//
// 128-byte Server signature: This field is used by Warcraft III to verify that the server its connected to is an official Blizzard server. More info available at http://liquipedia.net/starcraft/Blizzard_Weak_Digital_Signature.
//
// Format:
//
//      (UINT32) Logon type
//      (UINT32) Server token
//      (UINT32) UDP value
//    (FILETIME) MPQ int64
//      (STRING) MPQ filename
//      (STRING) ValueString
//
//    WAR3/W3XP Only:
//       (UINT8)[128] Server signature
//
type AuthInfoResp struct {
	ServerToken     uint32
	Unknown1        uint32
	MpqFileTime     uint64
	MpqFileName     string
	ValueString     string
	ServerSignature [128]byte
}

// Serialize encodes the struct into its binary form.
func (pkt *AuthInfoResp) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidAuthInfo)
	buf.WriteUInt16(uint16(154 + len(pkt.MpqFileName) + len(pkt.ValueString)))
	buf.WriteUInt32(0x02)
	buf.WriteUInt32(pkt.ServerToken)
	buf.WriteUInt32(pkt.Unknown1)
	buf.WriteUInt64(pkt.MpqFileTime)
	buf.WriteCString(pkt.MpqFileName)
	buf.WriteCString(pkt.ValueString)
	buf.WriteBlob(pkt.ServerSignature[:])
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *AuthInfoResp) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 154 {
		return ErrInvalidPacketSize
	}

	if buf.ReadUInt32() != 0x02 {
		return ErrUnexpectedConst
	}

	pkt.ServerToken = buf.ReadUInt32()
	pkt.Unknown1 = buf.ReadUInt32()
	pkt.MpqFileTime = buf.ReadUInt64()

	var err error
	if pkt.MpqFileName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size < 154+len(pkt.MpqFileName) {
		return ErrInvalidPacketSize
	}
	if pkt.ValueString, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 154+len(pkt.MpqFileName)+len(pkt.ValueString) {
		return ErrInvalidPacketSize
	}

	copy(pkt.ServerSignature[:], buf.ReadBlob(128))

	return nil
}

// AuthInfoReq implements the [0x50] SID_AUTH_INFO packet (C -> S).
//
// Sends information about the client's product and locale to Battle.net.
//
// Field descriptions:
//
//   Protocol ID: Battle.net's current Protocol ID is `0x00`. This field has only been seen with a value of `0x00`.
//   Platform code: Identifies the client's platform value.
//   Product code: Identifies the client's product value.
//   Version byte: Identifies the client's version number.
//   Language code: Identifies the client's language value.
//   Local IP: This is the local network IP of the client, in network byte (big-endian) order, for NAT compatibility. Can safely be set to `0.0.0.0`.
//   Timezone bias: Retrieve using [TIME_ZONE_INFORMATION](https://msdn.microsoft.com/en-us/library/windows/desktop/ms725481(v=vs.85).aspx) structure returned from [GetTimeZoneInformation()](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724421(v=vs.85).aspx)
//       Depending on whether the return value is `TIME_ZONE_ID_STANDARD` or `TIME_ZONE_ID_DAYLINE`, add `TZI.Bias + TZI.StandardBias` or `TZI.Bias + TZI.DaylightBias` to get the bias in minutes, where `TZI` is the returned `TIME_ZONE_INFORMATION` structure.
//       Alternatively, you may use [GetSystemTime()](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724390(v=vs.85).aspx), [GetLocalTime()](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724338(v=vs.85).aspx), and [SystemTimeToFileTime()](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724948(v=vs.85).aspx): convert both system and local time to FILETIMEs, subtract local time from system time, and divide by 600,000,000 to get the bias in minutes.
//   MPQ locale ID: This field is part of Blizzard's multi-lingual MPQ system and is used to specify which version of an MPQ should be used when the MPQ is available in multiple languages. Can safely be set to `0x00`, but you may also use something like  [GetUserDefaultLCID()](https://msdn.microsoft.com/en-us/library/windows/desktop/dd318135(v=vs.85).aspx).
//   User language ID: Can be retrieved with [GetUserDefaultLangID()](https://msdn.microsoft.com/en-us/library/windows/desktop/dd318134(v=vs.85).aspx)
//   Abbreviated country name and country name: Can be retrived with [GetLocaleInfo()](https://msdn.microsoft.com/en-us/library/windows/desktop/dd318101(v=vs.85).aspx) with LCType set to `LOCALE_SABBREVCTRYNAME` (three-letter code) and `LOCALE_SENGLISHCOUNTRYNAME` (English country name) respectively.
//
// Format:
//
//    (UINT32) Protocol ID
//    (UINT32) Platform code
//    (UINT32) Product code
//    (UINT32) Version byte
//    (UINT32) Language code
//    (UINT32) Local IP
//    (UINT32) Time zone bias
//    (UINT32) MPQ locale ID
//    (UINT32) User language ID
//    (STRING) Country abbreviation
//    (STRING) Country
//
type AuthInfoReq struct {
	PlatformCode        protocol.DWordString
	GameVersion         w3gs.GameVersion
	LanguageCode        protocol.DWordString
	LocalIP             net.IP
	TimeZoneBias        uint32
	MpqLocaleID         uint32
	UserLanguageID      uint32
	CountryAbbreviation string
	Country             string
}

// Serialize encodes the struct into its binary form.
func (pkt *AuthInfoReq) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidAuthInfo)
	buf.WriteUInt16(uint16(42 + len(pkt.CountryAbbreviation) + len(pkt.Country)))

	buf.WriteUInt32(0)
	buf.WriteBEDString(pkt.PlatformCode)
	pkt.GameVersion.Serialize(buf)
	buf.WriteBEDString(pkt.LanguageCode)

	if err := buf.WriteIP(pkt.LocalIP); err != nil {
		return err
	}

	buf.WriteUInt32(pkt.TimeZoneBias)
	buf.WriteUInt32(pkt.MpqLocaleID)
	buf.WriteUInt32(pkt.UserLanguageID)
	buf.WriteCString(pkt.CountryAbbreviation)
	buf.WriteCString(pkt.Country)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *AuthInfoReq) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 42 {
		return ErrInvalidPacketSize
	}

	if buf.ReadUInt32() != 0 {
		return ErrUnexpectedConst
	}

	pkt.PlatformCode = buf.ReadBEDString()
	pkt.GameVersion.Deserialize(buf)
	pkt.LanguageCode = buf.ReadBEDString()
	pkt.LocalIP = buf.ReadIP()
	pkt.TimeZoneBias = buf.ReadUInt32()
	pkt.MpqLocaleID = buf.ReadUInt32()
	pkt.UserLanguageID = buf.ReadUInt32()

	var err error
	if pkt.CountryAbbreviation, err = buf.ReadCString(); err != nil {
		return err
	}
	if size < 42+len(pkt.CountryAbbreviation) {
		return ErrInvalidPacketSize
	}
	if pkt.Country, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 42+len(pkt.CountryAbbreviation)+len(pkt.Country) {
		return ErrInvalidPacketSize
	}

	return nil
}

// AuthCheckResp implements the [0x51] SID_AUTH_CHECK packet (S -> C).
//
// Reports success or failure on the game key and version check.
//
// Result:
//   0x000: Passed challenge
//   0x100: Old game version (Additional info field supplies patch MPQ filename)
//   0x101: Invalid version
//   0x102: Game version must be downgraded (Additional info field supplies patch MPQ filename)
//   0x0NN: (where NN is the version code supplied in SID_AUTH_INFO): Invalid version code (note that 0x100 is not set in this case).
//   0x200: Invalid CD key (If you receive this status, official Battle.net servers will IP ban you for 1 to 14 days. Before June 15, 2011, this used to exclusively be 14 days)
//   0x201: CD key in use (Additional info field supplies name of user)
//   0x202: Banned key
//   0x203: Wrong product
//
// The last 4 codes also apply to the second CDKey, as indicated by a bitwise combination with `0x010`.
//
// If a patch file cannot be found, additional info is set to 'non-existent'. If either the executable size/date or the version code is wrong, the server will typically return a failure status.
//
// If the spawn flag was set to true in the client's request, and there is already a spawned key online, the result will be `0x201` with additional info set to `TOO MANY SPAWNS`.
//
// Format:
//
//    (UINT32) Result
//    (STRING) Additional Information
//
type AuthCheckResp struct {
	Result                AuthResult
	AdditionalInformation string
}

// Serialize encodes the struct into its binary form.
func (pkt *AuthCheckResp) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidAuthCheck)
	buf.WriteUInt16(uint16(9 + len(pkt.AdditionalInformation)))
	buf.WriteUInt32(uint32(pkt.Result))
	buf.WriteCString(pkt.AdditionalInformation)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *AuthCheckResp) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 9 {
		return ErrInvalidPacketSize
	}

	pkt.Result = AuthResult(buf.ReadUInt32())

	var err error
	if pkt.AdditionalInformation, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 9+len(pkt.AdditionalInformation) {
		return ErrInvalidPacketSize
	}

	return nil
}

// AuthCheckReq implements the [0x51] SID_AUTH_CHECK packet (C -> S).
//
// Contains the EXE Version and Hash as reported by `CheckRevision() and CDKey values.
//
// The data that should be hashed for `Hashed Key Data` is:
//
// * For 13/16 character keys (hashed using BSHA1):
//     1. (UINT32) Client Token
//     2. (UINT32) Server Token
//     3. (UINT32) Key Product value (from decoded CD key)
//     4. (UINT32) Key Public value (from decoded CD key)
//     5. (UINT32) 0
//     6. (UINT32) Key Private value (from decoded CD key)
// * For 26 character keys (hashed using standard SHA1):
//     1. (UINT32) Client Token
//     2. (UINT32) Server Token
//     3. (UINT32) Key Product value (from decoded CD key)
//     4. (UINT32) Key Public value (from decoded CD key)
//     6. (UINT8)[10] Key Private value (from decoded CD key)
//
// The data that should be used for EXE Information should be separated by one space, in the format of:
// 1. EXE Name (ex. `war3.exe`)
// 2. Last Modified Date (ex. `08/16/09`)
// 3. Last Modified Time (ex. `19:21:59`)
// 4. Filesize in bytes (ex. `471040`)
//
// An example of a valid string would be: `war3.exe 08/16/09 19:21:59 471040`
//
// The CD Key owner name must be no greater than 15 characters, otherwise it becomes trimmed by Battle.net.
//
// Spawn value can only be TRUE for STAR, JSTR, and W2BN. Any other game will cause unexpected results.
//
// Format:
//
//    (UINT32) Client Token
//    (UINT32) EXE Version
//    (UINT32) EXE Hash
//    (UINT32) Number of CD-keys in this packet
//    (UINT32) Spawn Key (1 is TRUE, 0 is FALSE)
//
//    For each Key:
//       (UINT32)     Key length
//       (UINT32)     Key Product value
//       (UINT32)     Key Public value
//       (UINT32)     Unknown (0)
//        (UINT8)[20] Hashed Key Data
//
//    (STRING) EXE Information
//    (STRING) Key owner name
//
type AuthCheckReq struct {
	ClientToken    uint32
	ExeVersion     uint32
	ExeHash        uint32
	CDKeys         []CDKey
	ExeInformation string
	KeyOwnerName   string
}

// CDKey stores the CD key information.
//
//  Format:
//    (UINT32)     Key length
//    (UINT32)     Key Product value
//    (UINT32)     Key Public value
//    (UINT32)     Unknown (0)
//     (UINT8)[20] Hashed Key Data
//
type CDKey struct {
	KeyLength       uint32
	KeyProductValue uint32
	KeyPublicValue  uint32
	HashedKeyData   [20]byte
}

// Serialize encodes the struct into its binary form.
func (pkt *AuthCheckReq) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidAuthCheck)
	buf.WriteUInt16(uint16(26 + len(pkt.CDKeys)*36 + len(pkt.ExeInformation) + len(pkt.KeyOwnerName)))

	buf.WriteUInt32(pkt.ClientToken)
	buf.WriteUInt32(pkt.ExeVersion)
	buf.WriteUInt32(pkt.ExeHash)
	buf.WriteUInt32(uint32(len(pkt.CDKeys)))
	buf.WriteUInt32(0)

	for i := 0; i < len(pkt.CDKeys); i++ {
		buf.WriteUInt32(pkt.CDKeys[i].KeyLength)
		buf.WriteUInt32(pkt.CDKeys[i].KeyProductValue)
		buf.WriteUInt32(pkt.CDKeys[i].KeyPublicValue)
		buf.WriteUInt32(0)
		buf.WriteBlob(pkt.CDKeys[i].HashedKeyData[:])
	}

	buf.WriteCString(pkt.ExeInformation)
	buf.WriteCString(pkt.KeyOwnerName)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *AuthCheckReq) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 26 {
		return ErrInvalidPacketSize
	}

	pkt.ClientToken = buf.ReadUInt32()
	pkt.ExeVersion = buf.ReadUInt32()
	pkt.ExeHash = buf.ReadUInt32()

	var numKeys = int(buf.ReadUInt32())
	if size < 26+numKeys*36 {
		return ErrInvalidPacketSize
	}

	if buf.ReadUInt32() != 0 {
		return ErrUnexpectedConst
	}

	if cap(pkt.CDKeys) < numKeys {
		pkt.CDKeys = make([]CDKey, 0, numKeys)
	}
	pkt.CDKeys = pkt.CDKeys[:numKeys]

	for i := 0; i < len(pkt.CDKeys); i++ {
		pkt.CDKeys[i].KeyLength = buf.ReadUInt32()
		pkt.CDKeys[i].KeyProductValue = buf.ReadUInt32()
		pkt.CDKeys[i].KeyPublicValue = buf.ReadUInt32()
		if buf.ReadUInt32() != 0 {
			return ErrUnexpectedConst
		}
		copy(pkt.CDKeys[i].HashedKeyData[:], buf.ReadBlob(20))
	}

	var err error
	if pkt.ExeInformation, err = buf.ReadCString(); err != nil {
		return err
	}
	if size < 26+len(pkt.CDKeys)*36+len(pkt.ExeInformation) {
		return ErrInvalidPacketSize
	}
	if pkt.KeyOwnerName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 26+len(pkt.CDKeys)*36+len(pkt.ExeInformation)+len(pkt.KeyOwnerName) {
		return ErrInvalidPacketSize
	}

	return nil
}

// AuthAccountCreateResp implements the [0x52] SID_AUTH_ACCOUNTCREATE packet (S -> C).
//
// The message reports the success or failure of an account creation attempt.
//
// Possible status codes:
//   0x00: Successfully created account name.
//   0x04: Name already exists.
//   0x07: Name is too short/blank.
//   0x08: Name contains an illegal character.
//   0x09: Name contains an illegal word.
//   0x0a: Name contains too few alphanumeric characters.
//   0x0b: Name contains adjacent punctuation characters.
//   0x0c: Name contains too many punctuation characters.
//   Any other: Name already exists.
//
// Format:
//
//    (UINT32)  Status
//
type AuthAccountCreateResp struct {
	Result AccountCreateResult
}

// Serialize encodes the struct into its binary form.
func (pkt *AuthAccountCreateResp) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidAuthAccountCreate)
	buf.WriteUInt16(8)
	buf.WriteUInt32(uint32(pkt.Result))
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *AuthAccountCreateResp) Deserialize(buf *protocol.Buffer) error {
	if readPacketSize(buf) != 8 {
		return ErrInvalidPacketSize
	}
	pkt.Result = AccountCreateResult(buf.ReadUInt32())
	return nil
}

// AuthAccountCreateReq implements the [0x52] SID_AUTH_ACCOUNTCREATE packet (C -> S).
//
// This message is sent to create an NLS-style account. It contains the client's salt and verifier values,
// which are saved by the server for use with future logons.
//
// Format:
//
//     (UINT8)[32] Salt (s)
//     (UINT8)[32] Verifier (v)
//    (STRING)     Username
//
type AuthAccountCreateReq struct {
	Salt     [32]byte
	Verifier [32]byte
	UserName string
}

// Serialize encodes the struct into its binary form.
func (pkt *AuthAccountCreateReq) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidAuthAccountCreate)
	buf.WriteUInt16(uint16(69 + len(pkt.UserName)))
	buf.WriteBlob(pkt.Salt[:])
	buf.WriteBlob(pkt.Verifier[:])
	buf.WriteCString(pkt.UserName)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *AuthAccountCreateReq) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 69 {
		return ErrInvalidPacketSize
	}

	copy(pkt.Salt[:], buf.ReadBlob(32))
	copy(pkt.Verifier[:], buf.ReadBlob(32))

	var err error
	if pkt.UserName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 69+len(pkt.UserName) {
		return ErrInvalidPacketSize
	}

	return nil
}

// AuthAccountLogonResp implements the [0x53] SID_AUTH_ACCOUNTLOGON packet (S -> C).
//
// Reports the success or failure of the logon request.
//
// Possible status codes:
//   0x00: Logon accepted, requires proof.
//   0x01: Account doesn't exist.
//   0x05: Account requires upgrade.
//   Other: Unknown (failure).
//
// Format:
//
//    (UINT32)     Status
//     (UINT8)[32] Salt (s)
//     (UINT8)[32] Server Key (B)
//
type AuthAccountLogonResp struct {
	Result    LogonResult
	Salt      [32]byte
	ServerKey [32]byte
}

// Serialize encodes the struct into its binary form.
func (pkt *AuthAccountLogonResp) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidAuthAccountLogon)
	buf.WriteUInt16(72)
	buf.WriteUInt32(uint32(pkt.Result))
	buf.WriteBlob(pkt.Salt[:])
	buf.WriteBlob(pkt.ServerKey[:])
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *AuthAccountLogonResp) Deserialize(buf *protocol.Buffer) error {
	if readPacketSize(buf) != 72 {
		return ErrInvalidPacketSize
	}
	pkt.Result = LogonResult(buf.ReadUInt32())
	copy(pkt.Salt[:], buf.ReadBlob(32))
	copy(pkt.ServerKey[:], buf.ReadBlob(32))
	return nil
}

// AuthAccountLogonReq implements the [0x53] SID_AUTH_ACCOUNTLOGON packet (C -> S).
//
// This message is sent to the server to initiate a logon. It consists of the client's public key and their UserName.
//
// The client's public key is a value calculated by the client and used for a single logon.
//
// Format:
//
//     (UINT8)[32] Client Key (A)
//    (STRING)     Username
//
type AuthAccountLogonReq struct {
	ClientKey [32]byte
	UserName  string
}

// Serialize encodes the struct into its binary form.
func (pkt *AuthAccountLogonReq) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidAuthAccountLogon)
	buf.WriteUInt16(uint16(37 + len(pkt.UserName)))
	buf.WriteBlob(pkt.ClientKey[:])
	buf.WriteCString(pkt.UserName)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *AuthAccountLogonReq) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 37 {
		return ErrInvalidPacketSize
	}

	copy(pkt.ClientKey[:], buf.ReadBlob(32))

	var err error
	if pkt.UserName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 37+len(pkt.UserName) {
		return ErrInvalidPacketSize
	}

	return nil
}

// AuthAccountLogonProofResp implements the [0x54] SID_AUTH_ACCOUNTLOGONPROOF packet (S -> C).
//
// Status:
//   0x00: Logon successful.
//   0x02: Incorrect password.
//   0x06: Account closed.
//   0x0E: An email address should be registered for this account.
//   0x0F: Custom error. A string at the end of this message contains the error.
//
// This message confirms the validity of the client password proof and supplies the server password proof.
//
// Format:
//
//    (UINT32)     Status
//     (UINT8)[20] Server Password Proof (M2)
//    (STRING)     Additional information
//
type AuthAccountLogonProofResp struct {
	Result                LogonProofResult
	ServerPasswordProof   [20]byte
	AdditionalInformation string
}

// Serialize encodes the struct into its binary form.
func (pkt *AuthAccountLogonProofResp) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidAuthAccountLogonProof)

	switch pkt.Result {
	case LogonProofCustomError:
		buf.WriteUInt16(uint16(29 + len(pkt.AdditionalInformation)))
	default:
		buf.WriteUInt16(28)
	}

	buf.WriteUInt32(uint32(pkt.Result))
	buf.WriteBlob(pkt.ServerPasswordProof[:])

	switch pkt.Result {
	case LogonProofCustomError:
		buf.WriteCString(pkt.AdditionalInformation)
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *AuthAccountLogonProofResp) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 28 {
		return ErrInvalidPacketSize
	}

	pkt.Result = LogonProofResult(buf.ReadUInt32())
	copy(pkt.ServerPasswordProof[:], buf.ReadBlob(20))

	switch pkt.Result {
	case LogonProofCustomError:
		if size < 29 {
			return ErrInvalidPacketSize
		}
		var err error
		if pkt.AdditionalInformation, err = buf.ReadCString(); err != nil {
			return err
		}
		if size != 29+len(pkt.AdditionalInformation) {
			return ErrInvalidPacketSize
		}
	}

	return nil
}

// AuthAccountLogonProofReq implements the [0x54] SID_AUTH_ACCOUNTLOGONPROOF packet (C -> S).
//
// This message is sent to the server after a successful SID_AUTH_ACCOUNTLOGON. It contains the client's password proof.
//
// Format:
//
//    (UINT8)[20] Client Password Proof (M1)
//
type AuthAccountLogonProofReq struct {
	ClientPasswordProof [20]byte
}

// Serialize encodes the struct into its binary form.
func (pkt *AuthAccountLogonProofReq) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidAuthAccountLogonProof)
	buf.WriteUInt16(24)
	buf.WriteBlob(pkt.ClientPasswordProof[:])
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *AuthAccountLogonProofReq) Deserialize(buf *protocol.Buffer) error {
	if readPacketSize(buf) != 24 {
		return ErrInvalidPacketSize
	}
	copy(pkt.ClientPasswordProof[:], buf.ReadBlob(20))
	return nil
}

// SetEmail implements the [0x59] SID_SETEMAIL packet (C -> S).
//
// Binds an email address to your account.
//
// Sending this message is optional. However, you should only send it when you receive status 0x0E from SID_AUTH_ACCOUNTLOGONPROOF.
//
// Format:
//
//    (STRING) Email Address
//
type SetEmail struct {
	EmailAddress string
}

// Serialize encodes the struct into its binary form.
func (pkt *SetEmail) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidSetEmail)
	buf.WriteUInt16(uint16(5 + len(pkt.EmailAddress)))
	buf.WriteCString(pkt.EmailAddress)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *SetEmail) Deserialize(buf *protocol.Buffer) error {
	var size = readPacketSize(buf)
	if size < 5 {
		return ErrInvalidPacketSize
	}
	var err error
	if pkt.EmailAddress, err = buf.ReadCString(); err != nil {
		return err
	}
	if size != 5+len(pkt.EmailAddress) {
		return ErrInvalidPacketSize
	}
	return nil
}

// ClanInfo implements the [0x75] SID_CLANINFO packet (S -> C).
//
// Received to declare that the client is a member of a clan.
//
// It is received when you first join a clan or immediately after logging on to tell you what clan you are in.
//
// Rank Values:
//   0x00: Initiate (Peon icon), in clan less than one week
//   0x01: Initiate (Peon icon)
//   0x02: Member (Grunt icon)
//   0x03: Officer (Shaman icon)
//   0x04: Leader (Chieftain icon)
//
// Format:
//
//     (UINT8) Unknown (0)
//    (UINT32) Clan tag
//     (UINT8) Rank
//
type ClanInfo struct {
	Tag  protocol.DWordString
	Rank ClanRank
}

// Serialize encodes the struct into its binary form.
func (pkt *ClanInfo) Serialize(buf *protocol.Buffer) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidClanInfo)
	buf.WriteUInt16(10)
	buf.WriteUInt8(0)
	buf.WriteBEDString(pkt.Tag)
	buf.WriteUInt8(uint8(pkt.Rank))
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *ClanInfo) Deserialize(buf *protocol.Buffer) error {
	if readPacketSize(buf) != 10 {
		return ErrInvalidPacketSize
	}
	if buf.ReadUInt8() != 0 {
		return ErrUnexpectedConst
	}
	pkt.Tag = buf.ReadBEDString()
	pkt.Rank = ClanRank(buf.ReadUInt8())
	return nil
}
